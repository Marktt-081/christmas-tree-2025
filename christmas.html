<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .text {
            position: absolute;
            top: 30%;
            left: 20px;
            color: #fff;
            font-family: "Monotype Corsiva", cursive;
            font-size: 2.5vw;
            user-select: none;
        }
        .tip {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #aaa;
            font-size: 14px;
            user-select: none;
        }
    </style>
</head>
<body>
    <div class="text">
        <div>Merry Christmas</div>
        <div style="margin-top: 10px;">To 戴乐陶宝贝</div>
    </div>
    <div class="tip">点一下屏幕有你想听的哦 ❄️</div>
    <canvas id="christmasTree"></canvas>
    <!-- 音频标签：替换成你的圣诞音乐MP3链接 -->
    <audio id="bgm" loop preload="auto">
        <source src="C:\Users\17131\Desktop\christmas-music.mp3" type="audio/mpeg">
    

    <script>
        // ================== 全局参数 ==================
        const WIDTH = window.innerWidth;
        const HEIGHT = window.innerHeight;
        const TAU = Math.PI * 2;

        // 粒子数量（适配移动端，适当减少）
        const TREE_POINTS = 20000;
        const GROUND_POINTS = 2000;
        const STAR_POINTS = 800;
        const HEART_POINTS = 800;
        const SNOW2D_POINTS = 8;

        // 相机参数
        const CAM_DIST = 13;
        const CAM_HEIGHT = 6.0;
        const PITCH = -0.25;
        const TREE_HEIGHT = 12.0;

        // 获取画布和上下文
        const canvas = document.getElementById('christmasTree');
        const ctx = canvas.getContext('2d');
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        // ================== 音频控制 ==================
        const bgm = document.getElementById('bgm');
        const tip = document.querySelector('.tip');
        let musicPlayed = false;

        // 监听用户点击/触摸，触发音乐播放
        function playMusicOnInteraction() {
            if (musicPlayed) return;
            bgm.play().then(() => {
                musicPlayed = true;
                tip.style.display = 'none'; // 隐藏提示
            }).catch(err => {
                console.log('播放失败:', err);
            });
            // 只触发一次
            document.removeEventListener('click', playMusicOnInteraction);
            document.removeEventListener('touchstart', playMusicOnInteraction);
        }

        // 绑定交互事件
        document.addEventListener('click', playMusicOnInteraction);
        document.addEventListener('touchstart', playMusicOnInteraction);

        // ================== 工具函数（替代 Python 内置函数） ==================
        function random(min, max) {
            if (max === undefined) {
                max = min;
                min = 0;
            }
            return Math.random() * (max - min) + min;
        }

        function randomInt(min, max) {
            return Math.floor(random(min, max + 1));
        }

        function gauss(mean, stdDev) {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            return mean + stdDev * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        // ================== 生成圣诞树 ==================
        function genTreePoints() {
            const pts = [];
            const loops = 9;
            const spiralN = Math.floor(TREE_POINTS * 0.7);

            // 70% 螺旋灯带
            for (let i = 0; i < spiralN; i++) {
                const u = Math.random();
                const h = Math.pow(u, 1.6);
                const y = TREE_HEIGHT * h + 0.2;
                let baseR = Math.pow(1 - h, 1.1) * 3.2;
                const branchWave = Math.max(0.0, Math.sin((h * 5.8 + 0.15) * TAU));
                const branchFactor = 1.0 + 0.65 * branchWave;
                baseR *= branchFactor;

                const t = u * loops * TAU;
                const angle = t + random(-0.22, 0.22);
                const r = baseR * random(0.85, 1.08);

                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                // 颜色计算
                const midBoost = Math.max(0.15, 1.0 - Math.abs(h - 0.55) * 1.5);
                const baseG = 155 + Math.floor(90 * midBoost);
                const baseB = 185 + Math.floor(70 * midBoost);

                let color = [
                    255,
                    Math.min(255, baseG + randomInt(-15, 20)),
                    Math.min(255, baseB + randomInt(-15, 35))
                ];

                // 点缀更亮的小灯
                if (Math.random() < 0.08) {
                    color = [255, 255 - randomInt(0, 35), 230 + randomInt(0, 25)];
                }

                pts.push([x, y, z, color]);
            }

            // 30% 随机填充
            const fillN = TREE_POINTS - spiralN;
            for (let i = 0; i < fillN; i++) {
                const h = Math.pow(Math.random(), 1.9);
                const y = TREE_HEIGHT * h + 0.2 + random(-0.08, 0.08);

                let baseR = Math.pow(1 - h, 1.1) * 4.3;
                const branchWave = Math.max(0.0, Math.sin((h * 5.8 + 0.15) * TAU));
                const branchFactor = 1.0 + 0.65 * branchWave;
                baseR *= branchFactor;

                const r = baseR * Math.sqrt(Math.random());
                const angle = Math.random() * TAU;

                const x = Math.cos(angle) * r + random(-0.08, 0.08);
                const z = Math.sin(angle) * r + random(-0.08, 0.08);

                const g = randomInt(165, 225);
                const b = randomInt(190, 250);
                const color = [255, g, b];
                pts.push([x, y, z, color]);
            }

            return pts;
        }

        // ================== 地面光环 ==================
        function genGroundPoints() {
            const pts = [];
            const rings = [4.6, 6.0, 7.4, 8.8, 10.2, 11.4];
            for (let i = 0; i < GROUND_POINTS; i++) {
                const ring = rings[Math.floor(random(0, rings.length))];
                const r = gauss(ring, 0.3);
                const theta = Math.random() * TAU;
                const x = Math.cos(theta) * r;
                const z = Math.sin(theta) * r;
                const y = -0.25;

                let c;
                if (Math.random() < 0.15) {
                    c = randomInt(235, 255);
                } else {
                    c = randomInt(190, 235);
                }
                const color = [c, c, 255];
                pts.push([x, y, z, color]);
            }
            return pts;
        }

        // ================== 空中 3D 小亮点 ==================
        function genStarPoints() {
            const pts = [];
            for (let i = 0; i < STAR_POINTS; i++) {
                const x = random(-18.0, 18.0);
                const z = random(-18.0, 18.0);
                const y = random(3.0, 18.0);
                const base = randomInt(215, 255);
                const color = [base, base, 255];
                pts.push([x, y, z, color]);
            }
            return pts;
        }

        // ================== 树顶 3D 爱心 ==================
        function genHeartPoints() {
            const pts = [];
            const scale = 0.9;
            const topY = TREE_HEIGHT + 0.05;

            while (pts.length < HEART_POINTS) {
                const x = random(-1.3, 1.3);
                const y = random(-1.4, 1.4);

                const f = Math.pow(x * x + y * y - 1.0, 3) - x * x * Math.pow(y, 3);

                if (f <= 0.0) {
                    const wx = x * scale * 0.8;
                    const wy = topY + (y + 1.0) * scale * 0.5;
                    const wz = random(-0.18, 0.18);

                    const dist = Math.hypot(x, y);
                    const factor = Math.max(0.35, 1.15 - 0.5 * dist);
                    const r = 255;
                    let g = Math.floor(130 * factor + 80);
                    let b = Math.floor(190 * factor + 70);
                    g = Math.max(120, Math.min(255, g));
                    b = Math.max(120, Math.min(255, b));

                    pts.push([wx, wy, wz, [r, g, b]]);
                }
            }

            return pts;
        }

        // ================== 前景 2D 大雪花 ==================
        function initSnow2d() {
            const flakes = [];
            for (let i = 0; i < SNOW2D_POINTS; i++) {
                const x = random(0, WIDTH);
                const y = random(-80, -10);
                const radius = random(10.0, 16.0);
                const speed = random(30.0, 45.0);
                const travel = HEIGHT + 80 - y;
                const life = travel / speed;
                const maxLife = life;
                flakes.push([x, y, radius, speed, life, maxLife]);
            }
            return flakes;
        }

        function respawnFlake(f) {
            const x = random(0, WIDTH);
            const y = random(-80, -10);
            const radius = random(10.0, 16.0);
            const speed = random(30.0, 45.0);
            const travel = HEIGHT + 80 - y;
            const life = travel / speed;
            const maxLife = life;
            f[0] = x;
            f[1] = y;
            f[2] = radius;
            f[3] = speed;
            f[4] = life;
            f[5] = maxLife;
        }

        function updateSnow2d(flakes, dt) {
            for (const f of flakes) {
                let [x, y, r, v, life, maxLife] = f;
                y += v * dt;
                life -= dt;
                if (life <= 0 || y > HEIGHT + 50) {
                    respawnFlake(f);
                } else {
                    f[1] = y;
                    f[4] = life;
                }
            }
        }

        function drawSnow2d(flakes) {
            for (const f of flakes) {
                const [x, y, r, v, life, maxLife] = f;
                if (maxLife <= 0) continue;

                const phase = life / maxLife;
                let alpha = phase > 0.3 ? 255 : Math.floor(255 * (phase / 0.3));
                alpha = Math.max(0, Math.min(255, alpha));

                const cx = Math.floor(x);
                const cy = Math.floor(y);

                const r1 = Math.max(1, Math.floor(r * 1.3));
                const r2 = Math.max(1, Math.floor(r * 1.0));
                const r3 = Math.max(1, Math.floor(r * 0.75));
                const r4 = Math.max(1, Math.floor(r * 0.55));
                const r5 = Math.max(1, Math.floor(r * 0.45));

                const a1 = Math.floor(alpha / 20);
                const a2 = Math.floor(alpha / 12);
                const a3 = Math.floor(alpha / 6);
                const a4 = Math.floor(alpha / 3);
                const a5 = alpha;

                // 绘制多层雪花（模拟光晕）
                if (a1 > 0) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r1, 0, TAU);
                    ctx.fillStyle = `rgba(255, 255, 255, ${a1 / 255})`;
                    ctx.fill();
                }
                if (a2 > 0) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r2, 0, TAU);
                    ctx.fillStyle = `rgba(255, 255, 255, ${a2 / 255})`;
                    ctx.fill();
                }
                if (a3 > 0) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r3, 0, TAU);
                    ctx.fillStyle = `rgba(255, 255, 255, ${a3 / 255})`;
                    ctx.fill();
                }
                if (a4 > 0) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r4, 0, TAU);
                    ctx.fillStyle = `rgba(255, 255, 255, ${a4 / 255})`;
                    ctx.fill();
                }
                if (a5 > 0) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r5, 0, TAU);
                    ctx.fillStyle = `rgba(255, 255, 255, ${a5 / 255})`;
                    ctx.fill();
                }
            }
        }

        // ================== 3D -> 2D 投影 ==================
        function projectPoint(x, y, z, angle) {
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            const xz = x * cosA - z * sinA;
            const zz = x * sinA + z * cosA;

            const cosP = Math.cos(PITCH);
            const sinP = Math.sin(PITCH);
            const yp = y * cosP - zz * sinP;
            const zp = y * sinP + zz * cosP;

            const zpFinal = zp + CAM_DIST;
            const ypFinal = yp - CAM_HEIGHT;

            if (zpFinal <= 0.1) return null;

            const f = (HEIGHT * 0.63) / zpFinal;
            const sx = Math.floor(WIDTH / 2 + xz * f);
            const sy = Math.floor(HEIGHT / 2 - ypFinal * f);
            const depth = zpFinal;
            return [sx, sy, depth];
        }

        // ================== 主程序 ==================
        function main() {
            // 生成所有粒子
            const tree = genTreePoints();
            const ground = genGroundPoints();
            const stars = genStarPoints();
            const heart = genHeartPoints();
            const snow2d = initSnow2d();

            let angle = 0.0;
            let lastTime = performance.now();

            // 动画循环
            function animate(currentTime) {
                requestAnimationFrame(animate);
                const dt = (currentTime - lastTime) / 1000.0;
                lastTime = currentTime;

                // 清空画布
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                // 更新雪花
                updateSnow2d(snow2d, dt);

                // 投影并收集所有要绘制的点
                const drawList = [];
                const allPoints = [...tree, ...ground, ...stars, ...heart];
                for (const [x, y, z, color] of allPoints) {
                    const proj = projectPoint(x, y, z, angle);
                    if (proj) {
                        const [sx, sy, depth] = proj;
                        const size = Math.max(1, Math.floor(3.6 - depth * 0.13));
                        drawList.push([depth, sx, sy, size, color]);
                    }
                }

                // 按深度排序（远的先画，近的后画）
                drawList.sort((a, b) => b[0] - a[0]);

                // 绘制所有粒子
                for (const [_, sx, sy, size, [r, g, b]] of drawList) {
                    if (sx >= 0 && sx < WIDTH && sy >= 0 && sy < HEIGHT) {
                        ctx.beginPath();
                        ctx.arc(sx, sy, size, 0, TAU);
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fill();
                    }
                }

                // 绘制前景雪花
                drawSnow2d(snow2d);

                // 更新旋转角度
                angle += 0.0045;
            }

            // 启动动画
            requestAnimationFrame(animate);
        }

        // 窗口大小适配
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // 启动主程序
        main();
    </script>
</body>
</html>